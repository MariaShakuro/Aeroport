  Java Core, Unit Testing, основные Design Patterns, Рефакторинг с упором на переход от процедурного к ООП решению и обратно,
форматы файлов, регулярные выражения,дизайн и архитектуру, разбиение на модули, варианты границ и способы их пересечения,
REST сервисы (+ при желании отказоустойчивость, различные Proxy, балансировщики нагрузки и работа через очереди сообщений)
 и UI (консоль, Web, нативные Android и iOS приложения, Desktop), API тесты на RestAssured и UI тесты на Selenium \ Selenide и Appium)


 +++Добавить обработку исключений Rest с ControllerAdvice и RestControllerAdvice аннотации
 +++Добавить валидацию данных(Bean Validation/Hibernate Validation)

1 ЭТАП
Необходимо реализовать консольное приложение, которое:
1)  Читает данные из входного файла;
2)  Обрабатывает полученную информацию;
3)  Записывает данные в выходной файл;

//Для билета
Входной и выходной файл могут быть следующих форматов: 
plain text, xml, json, yaml 
//Для билета
Так же входные и выходные файлы могут быть архивированы и зашифрованы, разными engines
(только архивирован, только зашифрован, сперва архивирован, а потом зашифрован и наоборот).

«Тип» входного и выходного файла задаются параметрами консоли.
//В процессе приложения
Приложение реализовать двумя способами: 
без использования Design Patterns 
c использованием Design Patterns (Decorator и Builder … можно оформить Builder в виде Singleton-а)

Обработка информации на первом этапе:
//Подсчет стоимости со скидками, милями,общее кол-во билетов и тд
найти все арифметические операции во входном файле и заменить на результаты в выходном файле.
Реализовать фильтрацию двумя способами без использования регулярных выражений 
 с использованием регулярных выражений
 (а так же третьим :) найти библиотеку, которая все делает за вас, парсинг и калькуляцию, такие есть и не одна). 


Следующие шаги по нашей задаче:
1)  Добавить UI:
a.  консольный;
b.  использую любую графическую библиотеку Java на Ваш выбор;
c.  сравнить CLI и UI based реализации;
2)  Реализовать логику как Web Service:
a.  Rest, используя любой Java engine;
b.  SOAP, используя любой Java engine;
3)  Соединить все вместе UI и Web Service;

Примеры атомарных подзадач:
Чтение \ запись текстовый файл;
Чтение \ запись xml файл (используя специальный API для чтения XML и не используя – чтение по строчно);
Чтение \ запись json файл (используя специальный API для чтения XML и не используя – чтение по строчно);
Архивация \ де Архивация файла используя ту или иную реализацию Zip;
Архивация \ де Архивация файла используя ту или иную реализацию Rar;
Шифровка \ де Шифровка файла используя любую библиотеку шифрования;
Покрыть все эти атомарные задачи Unit Test-ами;
 Каждая из атомарный задач простая как грабли, в несколько строк кода, причем решение можно нагуглить даже не зная синтаксиса языка.



1.Настраиваемые Unit Tests(JUnit/Mockito)
2.UI:
-Консольный CLI
-Desktop JavaFX
-Web (React.js)
Ваше приложение должно поддерживать динамическое подключение различных UI и других плагинов. Это можно сделать, создавая интерфейсы для плагинов и их реализаций.
*UI плагин
*CLI плагин
3.Нативные приложения:
-Android( Kotlin)
-IOS(?)
4.Тестирование:
-API на RestAssured
-UI на Selenium/Selenide/Appium
5.Отказоустойчивость:
-Hystrix для BookingService
6.Балансировка нагрузки:
-Spring Cloud LoadBalancer
7.ОЧередь сообщений:
-Конфигурация RabbitMQ
8.Proxy:

План:
1.BookingService:
Обработка бронирования билетов.
Создание и сохранение билетов в базу данных.
2.FlightService:
Управление информацией о рейсах.
Предоставление данных о рейсах для других сервисов.
3.DisplayService:
Отображение информации для пользователей.
Генерация отчетов и визуализация данных.
4.TicketService (основной сервис для вашей задачи):
Чтение данных из входного файла.
Обработка полученной информации (подсчет стоимости билетов, замена арифметических операций результатами, фильтрация данных).
Запись данных в выходной файл в различных форматах (plain text, xml, json, yaml).
Архивация и шифровка файлов с использованием различных методов (Zip, Rar, AES, и другие).
Асинхронная обработка данных с использованием Kafka/RabbitMQ.


FlightService:
1)Информация о рейсах в реальном времени: Предоставление актуальной информации о статусе рейсов, включая задержки, отмены и обновленные времена прибытия/вылета.
2)Планирование расписания рейсов: Автоматическое создание и обновление расписания рейсов на основе данных авиакомпаний и аэропортов.
3)Управление экипажем: Назначение и управление экипажем для каждого рейса, включая пилотов, стюардов и наземный персонал.
4)Управление самолетами: Мониторинг и управление парком самолетов, включая планирование технического обслуживания и ремонтных работ.
5)Функция поиска рейсов: Возможность поиска рейсов по различным параметрам, таким как направление, дата, время вылета/прибытия и авиакомпания.
6)Аналитика рейсов: Сбор и анализ данных о рейсах для выявления тенденций, улучшения качества обслуживания и оптимизации процессов.
7)Интеграция с аэропортами: Обмен данными с аэропортами для более точного планирования и координации рейсов.
8)Автоматическое уведомление о пересадках: Информирование пассажиров о пересадках и возможных изменениях в маршруте.

BookingService:

1)Отмена бронирования: Возможность отменить бронирование билета с возвратом средств или с определенной комиссией за отмену.
2)Изменение бронирования: Возможность изменять детали бронирования, такие как даты, места и информация о пассажирах.
3)Отправка уведомлений: Отправка электронных писем или SMS-уведомлений пользователям о статусе их бронирования, изменениях и напоминаниях.
4)Проверка доступности: Проверка наличия свободных мест на выбранный рейс и информирование пользователя в реальном времени.
5)Применение скидок и промокодов: Возможность использовать скидочные купоны и промокоды для получения дополнительных скидок на бронирование.
6)Взаимодействие с платежными системами: Интеграция с различными платежными системами для обработки платежей.
7)Функция множества пассажиров: Поддержка бронирования для групп, включая возможность добавления нескольких пассажиров в одно бронирование.
8)Управление бронированиями: Просмотр и управление всеми текущими и прошлыми бронированиями пользователя.